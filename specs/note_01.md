# **Выбор темы**

У меня появилась потребность в поиске съема новой квартиры. Я начал искать выгодоное мне предложение на интернет платформах,
таких как [Onliner.by[1]](onliner.by), [Realt,by[2]](Realt,by), [Domovita.by[3]](Domovita.by), но столкнулся с проблемой:
каждый раз, когда ты открыаешь сайт в поиске новых объявлений, тебе приходить скурпулезно перебирать все старые, чтобы среди них выявить новое обхявление. Это достаточно хлопотное дельце. Позже, я нашел Flatty (https://t.me/FlattyBy), telegram-bot, который пресылает только новые объявления с платформ по аренде недвижимости. Но там есть больой минус: нет возможности задать фильтры, для получения только тех объявлений, которые подходят под твои критерии поиска. Поэтому и возикла идея реализовать в текущем КП телеграм-бот (помощнк в сфере аренды недвижимости), который бы мог приылать только те новые объяаления, которые будут подходить под Ваши критерии поиска.

# **Выбор провайдера/архитектуры/необходимых сервисов**

## Выбор провайдера?

В качестве реализации бэкенда, меня давно была интересна [Serverless[10]](https://www.serverless.com/) (микросервисная архитектуры??), поэтому я сразу решил реализовывать своий бэкенд с таким подходом. [Serverless[10]](https://www.serverless.com/) подзразумевает использовать облачные вычесления, поэтому после определения, что я буду реализовывать [Serverless[10]](https://www.serverless.com/) архитектуру, стал вопрос выбора облачного провайдера.

Текущие популрные облачные провайдеры: AWS (Amazon Web Services), MS Azure, Google Cloud Platform, Яндекс.Облако

**Выбор пал на изучение AW**S, тк он самый ТОП среди всех, имееет более 174 сервисов, и покрывает более чем 85% рынка и выгоднее выше перечисленных

Пару статей почему:

- [тут есть график, AWS круче всех](https://www.datamation.com/cloud-computing/aws-vs-azure-vs-google-cloud-comparison.html)
- [тут графики, которые относятся к AWS Lambda (реализация Serveless на AWS)](https://mikhail.io/serverless/coldstarts/aws/)
- [тут графики и сравнение реализации Serverless на разных провайдерах (AWS Lambda, GCP functions, Azure)](https://mikhail.io/serverless/coldstarts/big3/)

![aws-azure-gcp](./screenshots/aws-azure-gcp.jpg)

## разработка/имплементация архитектуры?

Мы определились с облачным провадером: AWS;
следующим шагом нам надо продумать микросервисную архитектуру, какие сервисы нам необходимы, и как их использовать/связать.

- AWS Lambda
- AWS APIGateway
- AWS DynamoDB
- AWS CloudWatch
- AWS System Manager
- AWS CloudFormation
- AWS S3
- AWS Cognito
- AWS AppSync
  - AWS VTL
- AWS Amplify (не описал)
- AWS SNS (не описал)

### **1. AWS Lambda**

Сразу ясно, что основная бизнес логика будет исполнятся Serverless с помощью [AWS Lambda [18]](https://docs.aws.amazon.com/lambda/index.html). Почему [AWS Lambda [18]](https://docs.aws.amazon.com/lambda/index.html)? .[ВСЕ ОТВЕТЫ ТУТ](https://aws.amazon.com/ru/lambda/features/). **[AWS Lambda [18]](https://docs.aws.amazon.com/lambda/index.html)** позволяет запускать программный код без выделения серверов и управления ими. Вы платите только за фактическое время вычисления. Если программный код не исполняется, оплата не требуется. С помощью Lambda можно запускать практически любые виды приложений и серверных сервисов, при этом не требуются какие-либо операции администрирования. Просто загрузите программный код, и Lambda обеспечит все ресурсы, необходимые для его исполнения, масштабирования и обеспечения высокой доступности. Можно настроить автоматический запуск программного кода из других сервисов AWS или вызывать его непосредственно из любого мобильного или интернет‑приложения.

**Вопрос: Что такое бессерверные вычисления?**

Бессерверные вычисления позволяют создавать и запускать приложения и сервисы, не беспокоясь о серверах. При бессерверных вычислениях приложение по‑прежнему работает на серверах, но управление этими серверами AWS полностью берет на себя. В основе бессерверных вычислений лежит сервис AWS Lambda, позволяющий запускать код без выделения серверов или управления ими.

> ПАРУ УМНЫХ ГРАФИКОВ

- [тут графики, которые относятся к AWS Lambda (реализация Serveless на AWS)](https://mikhail.io/serverless/coldstarts/aws/)
- [тут графики и сравнение реализации Serverless на разных провайдерах (AWS Lambda, GCP functions, Azure)](https://mikhail.io/serverless/coldstarts/big3/)

![aws-azure-gcp](./screenshots/.xdp_cold-starts-comparison.H41MV0)

> **сравнение Cold Start разных облачных провайдеров с разными языками**

---

> **Что такое холодный старт?** ❄️ При запуске бессерверной функции она будет оставаться активной (иначе говоря, горячей), пока вы ее запускаете. Ваш контейнер остается живым, готовым к исполнению. После периода бездействия ваш облачный провайдер сбросит контейнер, и ваша функция станет неактивной (иначе говоря, холодной). Холодный запуск происходит, когда вы выполняете неактивную функцию. Задержка возникает из-за того, что ваш облачный провайдер подготовит выбранный вами контейнер среды выполнения, а затем запустит вашу функцию.Короче говоря, этот процесс значительно увеличит время выполнения.

### **2. AWS APIGateway**

нужно для реализации https endpoint-ов. С помощью его легко сделать REST или тп

[AWS API Gateway[21]](https://docs.aws.amazon.com/apigateway/index.html) – это полностью управляемый сервис для разработчиков, предназначенный для создания, публикации, обслуживания, мониторинга и обеспечения безопасности API в любых масштабах. Через API приложения получают доступ к данным, бизнес‑логике или функциональным возможностям ваших серверных сервисов. API Gateway позволяет создавать API RESTful и WebSocket, которые являются главным компонентом приложений для двусторонней связи в режиме реального времени. [AWS API Gateway[21]](https://docs.aws.amazon.com/apigateway/index.html) поддерживает рабочие нагрузки в контейнерах и бессерверные рабочие нагрузки, а также интернет‑приложения.

[AWS API Gateway[21]](https://docs.aws.amazon.com/apigateway/index.html) берет на себя все задачи, связанные с приемом и обработкой сотен тысяч одновременных вызовов API, включая управление трафиком, поддержку CORS, авторизацию и контроль доступа, регулирование количества запросов, мониторинг и управление версиями API. Работа с API Gateway не требует минимальных платежей или стартовых вложений. Вы платите за полученные вызовы API и переданный объем данных и можете с помощью многоуровневой модели ценообразования API Gateway снизить свои расходы по мере масштабирования использования API.

### **Принцип работы API Gateway**

![API Gateway](./screenshots/.xdp_APIGateway-princip-diagram.I88PV0)

> В контекстке моего приложения, используется для того, чтобы сделать HTTP Endpoint (webhook для telegram-bot-а), который будет являтся тригером для вызова [Lambad функции (ссылка на функцию)](../src/telegram-bot/webhook.ts)

### **3. AWS DynamoDB**

[AWS DynamoDB[17]](https://docs.aws.amazon.com/dynamodb/index.html) – это база данных пар «ключ‑значение» и документов, которая обеспечивает задержку менее 10 миллисекунд при работе в любом масштабе. Это надежная полностью управляемая база данных для приложений в масштабе всего Интернета, которая работает в нескольких регионах с несколькими ведущими серверами и обладает встроенными средствами обеспечения безопасности, резервного копирования и восстановления, а также кэширования в памяти. DynamoDB может обрабатывать более 10 трлн запросов в день и справляться с пиковыми нагрузками, превышающими 20 млн запросов в секунду.

Многие из наиболее активно развивающихся компаний в мире, например Lyft, Airbnb и Redfin, а также крупные корпорации, такие как Samsung, Toyota и Capital One, используют масштабируемый и высокопроизводительный сервис DynamoDB для выполнения критически важных рабочих нагрузок.

[AWS DynamoDB[17]](https://docs.aws.amazon.com/dynamodb/index.html) - это полностью управляемая служба базы данных NoSQL, которая обеспечивает быструю и предсказуемую производительность с бесшовной масштабируемостью. Если вы разработчик, вы можете использовать Amazon DynamoDB для создания таблицы базы данных, которая может хранить и извлекать любой объем данных и обслуживать любой уровень трафика запросов. Amazon DynamoDB автоматически распределяет данные и трафик для таблицы по достаточному количеству серверов, чтобы обрабатывать объем запросов, указанный клиентом, и объем хранимых данных, сохраняя при этом стабильную и высокую производительность. Все элементы данных хранятся на твердотельных дисках (SSD).

> тут следует наверное вставить, я коллекции `OnlinerApartment` я использовал `TTl Attribute` для эффективного удаления объявлений из колекции. Это удаление производится автоматически и не снижает пропускную. способность бд и эти вызовы бесплатны, в отличие от тех, когда мы будем вручную выполнять `Delete` операции. **Ниже будет приведено описание `aws_dynamodb_table` которое задает `OnlinerApartment` коллекцию с определнием ttl атрибитом**. [Место в коде](../terraform/modules/tables/tables.tf)

```tf
resource "aws_dynamodb_table" "OnlinerApartment" {
  name     = "OnlinerApartment"
  hash_key = "id"

  attribute {
    name = "id"
    type = "N"
  }

  ttl {
    attribute_name = "expirationTime"
    enabled        = true
  }

  billing_mode = "PAY_PER_REQUEST"

  lifecycle {
    prevent_destroy = true
  }

  point_in_time_recovery {
    enabled = true
  }
}
```

**TTl Attribute** позволяет определить метку времени для каждого элемента, чтобы определить, когда элемент больше не нужен. Вскоре после даты и времени указанной метки времени DynamoDB удаляет элемент из таблицы, не снижая пропускной способности записи. TTL предоставляется без дополнительных затрат как средство уменьшения объемов хранимых данных за счет сохранения только тех элементов, которые остаются актуальными для потребностей вашей рабочей нагрузки.

TTL полезно, если вы храните элементы, которые теряют актуальность через определенное время. Ниже приведены примеры использования TTL:

- Удалите данные пользователя или датчика после одного года бездействия в приложении.
- Архивируйте просроченные элементы в озеро данных Amazon S3 через DynamoDB Streams и AWS Lambda.
- Храните конфиденциальные данные в течение определенного времени в соответствии с договорными или нормативными обязательствами.

### **4. AWS CloudWatch**

[AWS CloudWatch[25]](https://docs.aws.amazon.com/cloudwatch/index.html) - это сервис мониторинга и управления, который предоставляет данные и полезную аналитическую информацию для AWS, гибридных и локальных приложений и ресурсов инфраструктуры. С CloudWatch вы можете собирать и получать доступ ко всем своим производственным и рабочим данным в форме журналов и метрик с единой платформы. Это позволяет преодолеть проблему мониторинга отдельных систем и приложений в разрозненных хранилищах (сервер, сеть, база данных и т. Д.). CloudWatch позволяет отслеживать весь стек (приложения, инфраструктуру и службы) и использовать данные аварийных сигналов, журналов и событий для выполнения автоматических действий и сокращения среднего времени до разрешения (MTTR). Это высвобождает важные ресурсы и позволяет сосредоточиться на создании приложений и создании ценности для бизнеса.

[AWS CloudWatch[25]](https://docs.aws.amazon.com/cloudwatch/index.html) дает вам полезную информацию, которая поможет вам оптимизировать производительность приложений, управлять использованием ресурсов и понять работоспособность системы. CloudWatch обеспечивает видимость данных метрик и журналов до 1 секунды, хранение данных (метрики) в течение 15 месяцев и возможность выполнять вычисления по метрикам. Это позволяет выполнять исторический анализ для оптимизации затрат и получать в реальном времени аналитические данные по оптимизации приложений и ресурсов инфраструктуры.

> пример как это выглядит

![cloudwatch-metric-example](./screenshots/.xdp_cloudwatch-metric-example.PMYNV0)

> ниже кусок кода [отсюда](../serverless/globals.yml), для подключения `alarms` к моим Lambda функциям

```yml
# custom:
alerts:
  stages: # select which stages to deploy alarms to
    - prod
    - dev
  dashboards: true
  topics:
    alarm:
      topic: lambda-alarms-${opt:stage}-${self:service}
      notifications:
        - protocol: email
          endpoint: alexfomin2402@gmail.com
  alarms:
    - functionThrottles
    - functionErrors
```

> ниже кусок кода [отсюда](../terraform/modules/dynamodb_throttle_alarm/alarm.tf), для подключения `alarms` к моим таблицам [тут](../terraform/modules/alarms/dynamodb.tf)

```tf
variable "tables" {
  type = "list"
}

variable "alarm_action_arn" {}

resource "aws_cloudwatch_metric_alarm" "dynamodb_throttle_monitor" {
  count               = "${length(var.tables)}"
  alarm_name          = "dynamodb-throttled-${element(var.tables, count.index)}"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "1"
  metric_name         = "ThrottledRequests"
  namespace           = "AWS/DynamoDB"

  dimensions = {
    TableName = "${element(var.tables, count.index)}"
  }

  period                    = "60"
  statistic                 = "Sum"
  unit                      = "Count"
  threshold                 = "0"
  alarm_description         = "Alarm when requests to ${element(var.tables, count.index)} are throttled"
  insufficient_data_actions = []
  alarm_actions             = ["${var.alarm_action_arn}"]
}

```

### **5. AWS System Manager**

> в этом сервисе я юзаю только `Parameter store` !

[AWS System Manager[23]](https://docs.aws.amazon.com/systems-manager/index.html) `Parameter Store` обеспечивает безопасное иерархическое хранилище для управления данными конфигурации и секретами. Вы можете хранить такие данные, как пароли, строки базы данных, идентификаторы образов Amazon Machine Image (AMI) и коды лицензий в качестве значений параметров. Вы можете хранить значения в виде обычного текста или зашифрованных данных. Вы можете ссылаться на параметры Systems Manager в своих сценариях, командах, документах SSM, а также в рабочих процессах конфигурации и автоматизации, используя уникальное имя, указанное при создании параметра.

> Ниже преведен пример моего токена от телеграм бота, который хранится как `SecureString`, токен зашифрован с помощью симметричного ключа шифрования, за который отвечает [AWS KMS[24]](https://aws.amazon.com/kms/)

![cloudwatch-metric-example](./screenshots/.xdp_parameter-store.6VNOV0)

> Ниже преведен пример, как с помощью `Serverless` досать этот токен, который хранится в зашифрованом виде, и передать его в environment Lambda функции [отсюда](../src/telegram-notifier/serverless.yml)

```yml
service: telegram-notifier

frameworkVersion: '2'

plugins:
  - serverless-webpack
  - serverless-plugin-aws-alerts

provider:
  name: aws
  endpointType: regional
  runtime: nodejs12.x
  region: us-east-1
  stage: ${opt:stage, 'dev'}
  environment: # Service wide environment variables
    AWS_NODEJS_CONNECTION_REUSE_ENABLED: 1
    TG_BOT_TOKEN: '${ssm:/taphut/tg-bot-token~true}'
    USER_POOL_ID: ${env:USER_POOL_ID}
```

### **6. AWS CloudFormation**

> note: сервисы этого ресурса автоматически разворачиваются с помощью [Serverless[10]](https://www.serverless.com/)

[AWS CloudFormation [22]](https://docs.aws.amazon.com/cloudformation/) дает вам простой способ смоделировать набор связанных ресурсов AWS и сторонних поставщиков, быстро и последовательно предоставлять их и управлять ими на протяжении всего их жизненного цикла, рассматривая инфраструктуру как код. Шаблон CloudFormation описывает желаемые ресурсы и их зависимости, поэтому вы можете запускать и настраивать их вместе как стек. Вы можете использовать шаблон для создания, обновления и удаления всего стека как единого целого так часто, как вам нужно, вместо того, чтобы управлять ресурсами по отдельности. Вы можете управлять стеками и выделять их для нескольких учетных записей AWS и регионов AWS.

> ниже приведен скриншот моих стеков

![cloudformation-stacks](./screenshots/.xdp_my-cloudformation-stacks.OVJFV0)

> ниже приведен скриншот моих стеков

![onliner-crawler-dev-stack](./screenshots/.xdp_onliner-crawler-dev-stack.EO0QV0)

### **7. AWS S3**

[AWS S3[16]](https://docs.aws.amazon.com/s3/index.html) - это сервис объектного хранилища, который предлагает лучшую в отрасли масштабируемость, доступность данных, безопасность и производительность. Это означает, что клиенты всех размеров и отраслей могут использовать его для хранения и защиты любого объема данных для различных сценариев использования, таких как озера данных, веб-сайты, мобильные приложения, резервное копирование и восстановление, архивирование, корпоративные приложения, устройства IoT и большие аналитика данных. Amazon S3 предоставляет простые в использовании функции управления, позволяющие упорядочить данные и настроить точно настроенные средства управления доступом в соответствии с конкретными бизнес-требованиями и требованиями организации и нормативными требованиями. Amazon S3 рассчитан на надежность 99,999999999% (11 9) и хранит данные для миллионов приложений для компаний по всему миру.

> note: сейчас у меня там лежит только два типа вещей: [Stored State для Terraform](https://www.terraform.io/docs/backends/types/s3.html) и zip-файлы кода моих Lambda функции.

![s3-list](./screenshots/.xdp_s3-list.F8VWV0)

### **8. AWS Cognito**

[AWS Cognito[15]](https://docs.aws.amazon.com/cognito/) обеспечивает аутентификацию, авторизацию и управление пользователями для ваших веб-приложений и мобильных приложений. Ваши пользователи могут входить в систему напрямую, используя имя пользователя и пароль, или через третьих лиц, таких как Facebook, Amazon, Google или Apple.

Двумя основными компонентами Amazon Cognito являются пулы пользователей и пулы удостоверений. Пулы пользователей - это каталоги пользователей, которые предоставляют возможность регистрации и входа для пользователей вашего приложения. Пулы удостоверений позволяют предоставлять пользователям доступ к другим сервисам AWS. Вы можете использовать пулы удостоверений и пулы пользователей по отдельности или вместе.

**Пул пользователей Amazon Cognito и пул удостоверений, используемые вместе:**

На диаграмме показан типичный сценарий Amazon Cognito. Здесь цель состоит в том, чтобы аутентифицировать вашего пользователя, а затем предоставить ему доступ к другому сервису AWS.

- На первом этапе пользователь вашего приложения входит в систему через пул пользователей и получает токены пула пользователей после успешной аутентификации.
- Затем ваше приложение обменивает токены пула пользователей на учетные данные AWS через пул удостоверений.
- Наконец, пользователь вашего приложения может использовать эти учетные данные AWS для доступа к другим сервисам AWS, таким как Amazon S3 или DynamoDB.

![aws cognito](./screenshots/scenario-cup-cib2.png)

**Особенности Amazon Cognito**

**Пулы пользователей**

Пул пользователей - это каталог пользователей в Amazon Cognito. С помощью пула пользователей ваши пользователи могут входить в ваше веб-приложение или мобильное приложение через Amazon Cognito или объединяться через стороннего поставщика удостоверений (IdP). Независимо от того, входят ли ваши пользователи в систему напрямую или через третьих лиц, все члены пользовательского пула имеют профиль каталога, к которому вы можете получить доступ через SDK.

Пулы пользователей предоставляют:

- Услуги регистрации и авторизации.
- Встроенный настраиваемый веб-интерфейс для входа пользователей.
- Социальный вход через Facebook, Google, вход через Amazon и вход через Apple, а также через поставщиков удостоверений SAML и OIDC из вашего пользовательского пула.
- Управление каталогами пользователей и профили пользователей.
- Функции безопасности, такие как многофакторная аутентификация (MFA), проверка на наличие взломанных учетных данных, защита от перехвата учетной записи, а также проверка телефона и электронной почты.
- Индивидуальные рабочие процессы и миграция пользователей с помощью триггеров AWS Lambda.

### **9. AWS AppSync**

Организации предпочитают создавать API-интерфейсы с помощью GraphQL, поскольку он помогает им быстрее разрабатывать приложения, предоставляя интерфейсным разработчикам возможность запрашивать несколько баз данных, микросервисов и API-интерфейсов с помощью одной конечной точки GraphQL.

[AWS AppSync[19]](https://docs.aws.amazon.com/appsync/latest/devguide/welcome.html) - это полностью управляемый сервис, который упрощает разработку API-интерфейсов GraphQL, выполняя тяжелую работу по безопасному подключению к таким источникам данных, как AWS DynamoDB, Lambda и т. Д. Так же просто добавить кеши для повышения производительности, подписки для поддержки обновлений в реальном времени и клиентские хранилища данных, которые поддерживают синхронизацию автономных клиентов. После развертывания AWS AppSync автоматически масштабирует механизм выполнения GraphQL API вверх и вниз в соответствии с объемами запросов API.

![aws cognito](./screenshots/appsync.png)

**Обзор шаблона сопоставления преобразователя**

[AWS AppSync[19]](https://docs.aws.amazon.com/appsync/latest/devguide/welcome.html) позволяет отвечать на запросы GraphQL, выполняя операции с вашими ресурсами. Для каждого поля GraphQL, в котором вы хотите выполнить запрос или изменение, должен быть прикреплен преобразователь для связи с источником данных. Связь обычно осуществляется через параметры или операции, уникальные для источника данных.

**Резольверы** - это соединители между GraphQl и источником данных. Они сообщают [AWS AppSync[19]](https://docs.aws.amazon.com/appsync/latest/devguide/welcome.html), как преобразовать входящий запрос GraphQL в инструкции для вашего внутреннего источника данных и как преобразовать ответ из этого источника данных обратно в ответ GraphQL. Они написаны на языке шаблонов **Apache Velocity Template Language (VTL)**, который принимает ваш запрос в качестве входных данных и выводит документ JSON, содержащий инструкции для преобразователя. Вы можете использовать шаблоны сопоставления для простых инструкций, таких как передача аргументов из полей GraphQL, или для более сложных инструкций, таких как цикл по аргументам для создания элемента перед вставкой элемента в DynamoDB.

В [AWS AppSync[19]](https://docs.aws.amazon.com/appsync/latest/devguide/welcome.html) есть два типа преобразователей, которые используют шаблоны сопоставления немного по-разному: преобразователи модулей и преобразователи конвейеров.

> note: ниже приведен пример, преобразователи модулей и преобразователи конвейеров

![aws cognito](./screenshots/unit-pipeline-resolver.png)

> note: `onlinerApartments query` - [тут](../src/appsync/public/schema.graphql)

**Резолвер AWS AppSync DynamoDB** (например, для `onlinerApartments query` тут [request resolver](../src/appsync/public/apartments/onliner/request.vtl) и [response resolver](../src/appsync/public/apartments/onliner/response.vtl)) позволяет использовать GraphQL для хранения и извлечения данных в существующих таблицах Amazon DynamoDB в вашей учетной записи. Этот преобразователь работает, позволяя отображать входящий запрос GraphQL в вызов DynamoDB, а затем отображать ответ DynamoDB обратно в GraphQL. В этом разделе описаны шаблоны сопоставления для поддерживаемых операций DynamoDB.

## МОЖЕТ ЧТО-ТО ДОБАВИТЬ ЕЩЕ ПРО TELEGRAM-BOT клиент и Angular клиент?

> например: в процессе разработки я столкнулся с проблемой, что long-polling мне не подходит из-за спефицики AWS Lambda, и я выбрал реализовывать через **webhook**: те когда ты в боте отправляешь сообщене, оно приходит на сервера Telegram, а потом Telegram отправляет его на endpoint, который я указал. Этот трюк и называется **webhook** походу

### **10. Telegram API**

[Telegam API[29]](https://core.telegram.org/)

Bot API - это интерфейс на основе HTTP, созданный для разработчиков, заинтересованных в создании ботов для Telegram.

Боты Telegram - это особые учетные записи, для которых не требуется дополнительный номер телефона. Эти учетные записи служат интерфейсом для кода, выполняемого где-то на вашем сервере.

Чтобы использовать это, вам не нужно ничего знать о том, как работает протокол шифрования MTProto - промежуточный сервер на стороне Telegram будет обрабатывать все шифрование и связь с [Telegam API[29]](https://core.telegram.org/) за вас. Вы общаетесь с этим сервером через простой HTTPS-интерфейс, который предлагает упрощенную версию [Telegam API[29]](https://core.telegram.org/).

Пользователи могут взаимодействовать с ботами двумя способами:

- Отправляйте сообщения и команды ботам, открывая с ними чат или добавляя их в группы.
- Отправляйте запросы прямо из поля ввода, вводя @username бота и запрос. Это позволяет отправлять контент от встроенных ботов прямо в любой чат, группу или канал.

Сообщения, команды и запросы, отправленные пользователями, передаются в программное обеспечение, работающее на ваших серверах. Наш промежуточный сервер обрабатывает все шифрование и связь с Telegram API за вас. Вы общаетесь с этим сервером через простой HTTPS-интерфейс, который предлагает упрощенную версию Telegram API. Мы называем этот интерфейс нашим Bot API.

![architecture](./screenshots/telegram-bot-api-webhook.png)

---

> ## Я не собирался реализовывать полноценный браузерный клиент в рамках этого кп, а сделать это позже,тк я планирую продвигать эту тему дальше на диплом. Сейчас Angular есть с минимальным функционалом [тут](https://taphut-front.vercel.app/), там есть регистрация, логин, восстановление пароля, смена пароля, есть так же отдельная страница, где уже интегрирован Google OAuth, а так же GraphQL с пагинацей, который вытаскивает объявления, а так же добавил (чтобы протестить) для будущего функционоала получения учетной записи из телеги (ЧТОБЫ ПРИ ЖЕЛАНИИ, СВЯЗАТЬ WEB-овскую учетную запись и учетку пользователя telegram)

---

![architecture](./screenshots/.xdp_taphut-web-1.TK7TV0)

---

> ниже приведены сркины примера получения информации о учтеку в телеге через моего бота

---

![architecture](./screenshots/.xdp_taphut-web-2.MPNUV0)

---

![architecture](./screenshots/.xdp_telegram-oath.R6PSV0)

---

### Обобщенная диаграмма развертывания, совмещенная с диаграммой компонентов

![architecture](./screenshots/.xdp_architecture.PKFJV0)

# **Разработка**

## **3.1 натсройка проекта бэка (webpack, ESLint, Prettier и тп)**

**Основным языком разработки выбран [TypeScript[4]](https://www.typescriptlang.org/docs/handbook/utility-types.html).**

Преимущества [TypeScript[4]](https://www.typescriptlang.org/docs/handbook/utility-types.html). Если углубиться в технические детали, [TypeScript[4]](https://www.typescriptlang.org/docs/handbook/utility-types.html) дает вам:

1. Строгий набор текста
   Все остается так, как мы это определяем. Хотите, чтобы переменная всегда была числом? Тогда это всегда будет число.
2. Структурная типизация
   Незаменим, когда вы заботитесь о полном определении фактической структуры, которую вы используете. JavaScript позволяет делать много странных вещей, поэтому полагаться на конкретную структуру - гораздо более безопасное решение.
3. Введите аннотации.
   Удобный способ явно указать, какой тип следует использовать.
4. Вывод типа
   Неявная типизация выполняется самим [TypeScript[4]](https://www.typescriptlang.org/docs/handbook/utility-types.html), поэтому вашим разработчикам не нужно предоставлять типы, в которых компилятор может найти их самостоятельно.

**зачем нужен Webpack?**

он позволяет компилить TypeScript в JS И...

[Webpack[8]](https://webpack.js.org/) — это сборщик модулей. Он служит для упаковки кода для использования браузером. Он позволяет использовать последние возможности JavaScript с помощью Babel или использовать [TypeScript[4]](https://www.typescriptlang.org/docs/handbook/utility-types.html) и компилировать его в кроссбраузерный минифицированный код. Он также позволяет импортировать статические ресурсы в JavaScript.

> ### настройка TypeScript!!! [тут находится tsconfig](../tsconfig.json), [тут находится ESLint](../.eslintrc.js), [тут находится Webpack](../config/webpack.config.js)

**Выбор пакетного менеджера:**

[Yarn[9]](https://classic.yarnpkg.com/en/docs/) это новый менеджер пакетов, совместно созданный Facebook, Google, Exponent и Tilde.

Как можно прочитать в официальной документации, его целью является решение целого ряда проблем, с которыми столкнулись разработчики при использовании npm, а именно:

- установка пакетов не была достаточно быстрой и последовательной;
- существовали проблемы с безопасностью, так как npm позволяет пакетам запускать код при установке.

Независимо от того, устанавливается ли пакет с помощью npm или Yarn, при этом решается серия задач. В npm эти задачи выполняются последовательно и отдельно для каждого пакета, это значит, что пока пакет не установлен полностью, следующий пакет будет ждать. В [Yarn[9]](https://classic.yarnpkg.com/en/docs/) эти операции выполняются параллельно, что улучшает производительность.

**Выбор линтера:**

Хоть основной язык выбран [TypeScript[4]](https://www.typescriptlang.org/docs/handbook/utility-types.html), его линтер [TSLint[6]](https://palantir.github.io/tslint/) уже `deprecated`, поэтому вместо него мы будем использовтаь [ESLint[5]](https://eslint.org/docs/user-guide/configuring).

[ESLint[5]](https://eslint.org/docs/user-guide/configuring) это крутой инструмент, который позволяет проводить анализ качества вашего кода, написанного на любом выбранном стандарте JavaScript. Он приводит код к более-менее единому стилю, помогает избежать глупых ошибок, умеет автоматически исправлять многие из найденных проблем и отлично интегрируется со многими инструментами разработки.

**!!!** Также для расширение функционала [ESLint[5]](https://eslint.org/docs/user-guide/configuring) я подключил [Prettier[7]](https://prettier.io/docs/en/options.html)

> **ESLint config** [тут](../.eslintrc.js) и [тут](../.eslintignore), а ткаже **Prettier config** [тут](../.prettierrc.js) и [тут](../.prettierignore)

## **3.2 натсройка деплоя и управления инфраструктурой бэка на AWS (Serverless, Terraform)**

### Serverless

[Serverless[10]](https://www.serverless.com/) Framework помогает разрабатывать и развертывать функции [AWS Lambda[18]](https://docs.aws.amazon.com/lambda/index.html) вместе с необходимыми ресурсами инфраструктуры AWS. Это интерфейс командной строки, который предлагает структуру, автоматизацию и передовые методы прямо из коробки, позволяя вам сосредоточиться на создании сложных, управляемых событиями, бессерверных архитектур, состоящих из функций и событий.

Бессерверная платформа отличается от других платформ приложений, потому что:

- Он управляет вашим кодом, а также вашей инфраструктурой
- Он поддерживает несколько языков (Node.js, Python, Java и другие)

**Core Concepts**

Вот основные концепции [Serverless[10]](https://www.serverless.com/) Framework и их отношение к AWS и Lambda:

1. **Функции** - это функции AWS Lambda. Это независимая единица развертывания, подобная микросервису. Это просто код, развернутый в облаке, который чаще всего пишется для выполнения одной задачи, например:

   - Сохранение пользователя в базе
   - Обработка файла в базе данных
   - Выполнение запланированной задачи
     > Вы можете выполнять несколько задач в своем коде, но мы не рекомендуем делать это без уважительной причины. Лучше всего разделить проблемы, и Framework разработана, чтобы помочь вам легко разрабатывать и развертывать функции, а также управлять многими из них.

2. **События** - Все, что вызывает выполнение функции AWS Lambda, рассматривается Framework как событие. События - это инфраструктурные события на AWS, такие как:

   - Запрос конечной точки HTTP AWS API Gateway (например, для REST API)
   - Загрузка корзины AWS S3 (например, для изображения)
   - Таймер CloudWatch (например, запускается каждые 5 минут)
   - Тема AWS SNS (например, сообщение)
   - Предупреждение CloudWatch (например, что-то произошло)
   - И больше...
     > Когда вы определяете событие для своих функций AWS Lambda в Serverless Framework, платформа автоматически создает любую инфраструктуру, необходимую для этого события (например, конечную точку шлюза API), и настраивает ваши функции AWS Lambda для его прослушивания.

3. **Ресурсы** - это компоненты инфраструктуры AWS, которые используются вашими функциями, например:

   - Таблица AWS DynamoDB (например, для сохранения данных о пользователях / сообщениях / комментариях)
   - AWS S3 Bucket (например, для сохранения изображений или файлов)
   - Тема AWS SNS (например, для асинхронной отправки сообщений)
   - Все, что можно определить в CloudFormation, поддерживается Serverless Framework.
     > Бессерверная платформа не только развертывает ваши функции и события, которые их запускают, но также развертывает компоненты инфраструктуры AWS, от которых зависят ваши функции.

4. **Сервисы** - это организационная единица Framework. Вы можете думать об этом как о файле проекта, хотя у вас может быть несколько сервисов для одного приложения. Здесь вы определяете свои функции, события, которые их запускают, и ресурсы, которые используют ваши функции. Службу можно описать в формате YAML или JSON, используя соответственно файл с именем serverless.yml или serverless.json. Выглядит это так (пример [тут написанные мнобю модули, для сборки и подключения CloudWatch к сервису](../serverless/globals.yml), [тут AppSync Public GraphQL](../src/appsync/public/serverless.yml), [тут Onliner Crawler](../src/onliner-crawler/serverless.yml), [тут от Telegram bot-a](../src/telegram-bot/serverless.yml) и [тут от я schedule функии, которая находит достает новые объявления, и рассылает юзерам](../src/telegram-notifier/serverless.yml))

> МОЖЕТ В ПРИЛОЖЕНИЕ закинуть шаблон для сервиса? [находится тут](https://www.serverless.com/framework/docs/providers/aws/guide/serverless.yml/)

> В моем приложении я разделяю управление ресурсами: БД например буду менеджить Terraform, Lambda Фукнции с APIGAteway и AppSync с помощью Serverless

> **Ниже приведу пример деплоя с помощью Serverless AppSync Public GraphQL сервиса**

![terraform-plan-example](./screenshots/.xdp_serverless-deploy.YX2DV0)

### [Terraform[11]](https://www.terraform.io/)

[Terraform[11]](https://www.terraform.io/) – это инструмент от компании Hashicorp, помогающий декларативно управлять инфраструктрой. В данном случае не приходится вручную создавать инстансы, сети и т.д. в консоли вашего облачного провайдера; достаточно написать конфигурацию, в которой будет изложено, как вы видите вашу будущую инфраструктуру. Такая конфигурация создается в человеко-читаемом текстовом формате. Если вы хотите изменить вашу инфраструктуру, то редактируете конфигурацию и запускаете terraform apply. [Terraform[11]](https://www.terraform.io/) направит вызовы API к вашему облачному провайдеру, чтобы привести инфраструктуру в соответствие с конфигурацией, указанной в этом файле

Если перенести управление инфраструктурой в текстовые файлы, то открывается возможность вооружиться всеми излюбленными инструментами для управления исходным кодом и процессами, после чего переориентируем их для работы с инфраструктурой. Теперь инфраструктура подчиняется системам контроля версий, точно как исходный код, ее можно точно так же рецензировать или откатывать к более раннему состоянию, если что-нибудь пойдет неправильно.

Каждый раз, когда вы запускаете [Terraform[11]](https://www.terraform.io/), создается файл состояния - terraform.tfstate. В него записывается вся инфраструктура, которую вы создали. Например, когда вы запустите Terraform в каталоге `/my/terraform`, будет создан файл `/my/terraform/terraform.tfstate`.

Если вы используете [Terraform[11]](https://www.terraform.io/) для личного проекта, хранение состояния в одном terraform.tfstate на вашем компьютере - это нормальная практика. Но если вы будете использовать [Terraform[11]](https://www.terraform.io/) в продакшене, вы столкнетесь с несколькими проблемами:

1. **Общее хранилище.** Чтобы использовать Terraform для обновления инфраструктуры, каждому члену команды необходим доступ к одним и тем же файлам состояния Terraform. Это означает, что вам нужно хранить эти файлы в общем месте.
2. **Блокировка.** Когда данные передаются, вы сталкиваетесь с новой проблемой: блокировка. Без блокировки, если два члена команды одновременно запустят Terraform, это приведет к конфликтам, потере данных и повреждению файлов состояний.
3. **Изоляция.** При внесении изменений в инфраструктуру рекомендуется изолировать различные среды. Например, при внесении изменений в среду test или среду stage вы должны быть уверены, что работа в среде prod не нарушится.

Лучший способ управления общим хранилищем файлов состояния - использовать встроенную поддержку Terraform'ом удаленных бэкендов. Бэкенд определяет, как Terraform загружает и сохраняет состояние.

**Удаленные бэкенды решают такие проблемы:**

- **Человеческий фактор.** После того, как будет настроен удаленный бэкенд, Terraform будет автоматически загружать файл состояния из этого бэкенда каждый раз, когда вы будете запускать `terraform plan` или `terraform apply`.
- **Блокировка.** Запустив `terraform apply`, Terraform автоматически включит блокировку. И если в это время кто-то уже запустил `terraform apply`, то вам придется ждать. Но вы можете запустить `terraform apply` с параметром `-lock-timeout=<TIME>`, чтобы Terraform подождал заданное время. Пример: `-lock-timeout=10m` сообщит Terraform подождать 10 минут.
- **Шифрование секретов.** Удаленные бэкенды изначально поддерживают шифрование при передаче и шифрование самого файла состояния. Более того, эти бэкенды предоставляют способы настройки разрешений доступа (например, использование политик IAM с Amazon S3 Bucket), чтобы вы могли контролировать, кто имеет доступ к вашим файлам состояния и секретам, которые они могут содержать.

> **ССЫЛКИ В КОД:** [мой модуль, для создания удаленного бэкенда Terraform](../terraform/modules/stored-state/main.tf)

> **ССЫЛКИ В КОД:** [главное место, в котором я указываю удаленный бэкенд Terraform для управления инфраструктурой](../terraform/dev/aws.tf)

> **ССЫЛКИ В КОД:** [мой модуль, в котором прописаны коллекции DynamoDB](../terraform/modules/tables/tables.tf)

> **ССЫЛКИ В КОД:** [мой модуль, для подключения CloudWatch alarms к моим коллекциям DynamoDB](../terraform/modules/dynamodb_throttle_alarm/alarm.tf)

> **Ниже приведу пример, что будет, если выполнить деплой инфраструктуры с нескольких клиентов**

![terraform-plan-example](./screenshots/.xdp_parallel-deploy-terraform.RBZIV0)

> **Ниже приведу пример, что будет, если я удалю из Terraform инфраструктуры коллекцию DynamoDB**

![terraform-plan-example](./screenshots/.xdp_terraform-plan-example.A7UFV0)

### **[AWS Vault[30]](https://github.com/99designs/aws-vault)**

Так как мы работаем с облачным провадйером, нам нужно как-то хранить, и менеджить ключи, с помощью которых мы прохдим аутентификацию и авторизациб для деплоя.

[AWS Vault[30]](https://github.com/99designs/aws-vault) - это инструмент для безопасного хранения учетных данных AWS и доступа к ним в среде разработки.

[AWS Vault[30]](https://github.com/99designs/aws-vault) хранит учетные данные IAM в защищенном хранилище ключей вашей операционной системы, а затем генерирует из них временные учетные данные для предоставления вашей оболочке и приложениям. Он разработан как дополнение к инструментам AWS CLI и учитывает ваши профили и конфигурацию в `~/.aws/config`.

> **Ниже приведу пример работы AWS-VAULT**

![terraform-plan-example](./screenshots/.xdp_aws-vault.R97SV0)

### **!! ДЛЯ УДОБНОЙ РАБОТЫ/ДЕПЛОЯ C SERVERLESS FRAMWEORK, Я РАЗРАБОТАЛ SHELL SCRIPT, который облегчает деплой**

```sh
#!/bin/bash
display_serverless_directories() {
  echo ""
  echo "Available serverless directories:"
  find . -path ./node_modules -prune -o -name serverless.yml -print | sed 's/\/serverless.yml//;s/.\///'
}

SYNTAX_STRING='yarn sls [dev|prod] serverless_dir ...serverless_args'
EXAMPLE_STRING='yarn sls dev src/ticker logs -f refreshTicker'

if [ "$1" = "--help" ]; then
  echo "Help from the serverless command (pass this in place of ...serverless_args):"
  serverless --help
  display_serverless_directories
  echo ""
  echo "Command syntax: $SYNTAX_STRING"
  echo "Example: $EXAMPLE_STRING"
  exit
fi
if [ "$#" -lt "3" ]; then
  echo "Bad args. Syntax: $SYNTAX_STRING"
  echo "Example: $EXAMPLE_STRING"
  display_serverless_directories
  echo ""
  echo "yarn sls --help for more details on serverless commands"
  exit
fi

export stage=$1
export directory=$2
shift 2

branch=`git symbolic-ref -q --short HEAD`
if [ "$stage" = "prod" ]; then
  if echo $* | grep -q deploy; then
    if [ "$branch" != "master" ]; then
      echo "current branch $branch != master. Prod deploy disallowed"
      exit
    fi

    # ok, we're on master and it's a prod deploy

    # ensure we're up to date with remote
    git remote update
    local=$(git rev-parse master)
    remote=$(git rev-parse origin/master)
    if [ $local != $remote ]; then
      echo "your local checkout must be up to date before prod deployment!"
      exit
    fi
    echo "Good to go for prod deploy. On master, fully up to date with remote..."
  fi
fi



if [ "$stage" = "forceprod" ]; then
  echo "!!!!!Forcing prod deployment!!!!!"
  stage="prod"
fi

export $(cat config/$stage.env | xargs)

cd $directory
profile=$stage

export $(aws-vault exec $profile --no-session -- env | grep AWS)
serverless --profile $profile --stage $stage "$@" --color | grep -v "Load command"
```

## **3.3 описание разработки бэка (основные функции, бд, schedule events, GraphQL API, HTTP endpoitns)?**

### AWS Cognito, добавление UserPool-a и Google OAuth

Настройка AWS Cognito осуществлялась полностью с помощью браузерного клиента AWS Console.

Пошаговая инструкция с примерами приведена [здесь](https://docs.aws.amazon.com/cognito/latest/developerguide/aws-cognito-sign-up-aws-account.html).

> **Ниже приведу пример основной информации о моем UserPool-e**

![terraform-plan-example](./screenshots/.xdp_AWS-Cognito-summary-info.I7WCV0)

> **Ниже приведу пример user-ов в моем UserPool-e**

![terraform-plan-example](./screenshots/.xdp_AWS-Cognito-users.IAJIV0)

> **Ниже приведу пример груп пользователей в моем UserPool-e**

![terraform-plan-example](./screenshots/.xdp_AWS-Cognito-groups.AYUEV0)

> **Ниже приведу пример подключения Google OAuth**

![terraform-plan-example](./screenshots/.xdp_AWS-Cognito-Google-OAuth.4SSOV0)

## DynamoDB

**Коллекция** - `OnlinerApartment`:

- `id`: **number** // `Primary key` - те `hash_key` Attribute
- `expirationTime`: **number** // !! `TTL` Attribute
- `status`: **string** // принимает значения "OLD" и "NEW"
- `createdAt`: **string** // timestamp
- `updatedAt`: **string** // timestamp
- `apartment`: **Object** // объект с Onliner.by (`IOnlinerApartment`)
  - [там оочень больша модель IOnlinerApartment](../src/onliner-crawler/model.ts)

```ts
export interface IOnlinerApartment {
  id: number;
  price: {
    amount: string;
    currency: OnlinerCurrences;
    converted: {
      [key: string]: {
        amount: string;
        currency: OnlinerCurrences;
      };
    };
  };
  rent_type: OnlinerRentType;
  location: IOnlinerApartmentLocation;
  photo: string;
  contact: {
    owner: boolean;
  };
  created_at: string;
  last_time_up: string;
  up_available_in: number;
  url: string;
}

export type OnlinerCurrences = 'USD' | 'BYN';

export type OnlinerRentType = '1_rooms' | '2_rooms' | '3_rooms' | '4_rooms' | '5_rooms';

export interface IOnlinerApartmentLocation {
  address: string;
  user_address: string;
  latitude: number;
  longitude: number;
}
```

![dynamodb-onliner](./screenshots/.xdp_dynamodb-onliner.AE8JV0)

**Коллекция** - `OnlinerApartment`:

`hash_key` и `range_key` образуют **Primary Key**

- `chatId`: String; // идентификатор чата между пользователем и ботом, `hash_key`
- `filterName`: String; // наименования фильтра, `range_key`
- `createdAt`: String; // timestamp создания
- `updatedAt`: String; // timestamp редактирования
- `filter`: Map; // храни объект, реализующий IFilter интерфейс
  - [там оочень больша модель IOnlinerApartment](../src/onliner-crawler/model.ts)

```ts
export interface IFIlter {
  filterName: string;
  city?: string;
  currency?: Currency;
  minPrice?: number;
  maxPrice?: number;
  roomsNumber?: number;
}

export type Currency = 'USD' | 'BYN';
```

![dynamodb-onliner](./screenshots/.xdp_telegramUserFilter.ERXUV0)

## Onliner-Crawler сервис

> ВОТ ТУТ [serverless.yml config](../src/onliner-crawler/serverless.yml)

> ВОТ ТУТ [entry point (`handler` функция)](../src/onliner-crawler/onliner-crawler.ts)

Onliner-Crawler будет собирать данные с onliner, проверять их и отправлять новые данные в DynamoDB для следующей обработки.

запускается кажде 15 минут, описано в [serverless.yml config](../src/onliner-crawler/serverless.yml)

> а именно здечь

```yml
# ...
events:
  - schedule:
      name: onliner-crawler-event
      description: 'Run the Onliner Crawler to fetch data from Onliner'
      rate: rate(15 minutes)
# ...
```

**Обощенный алгоритм:**

1. Совершает первоначальный запрос на `Onliner API`, получает количество элементов, информацтю для пагинации
2. формируется массив запросов к `Onliner API` с параетрами пагинации
3. формируется паралелльное выполнение запросов к `Onliner API` batch-ами по 10 штук, и `timeout = 2500ms`, объявленя из ответов запроов складываются в объект `apartmentMap` типа ключ значение, где ключ - это уникальный идентификатор объявления с `Onliner API`, а значение - само объявлеие
4. Для оптимизации уменьшения количества запросов в БД, мы начинаем выполнять `SCAN` объявлений из нашей коллекции `OnlinerApartment`, и удаляем удаляем объявления из `apartmentMap`,которые пришли из нашей коллекции
   > (тк приходилось бы для каждого элемента совершать операцию `PutItem` с условием выполнения запроса, что безусловно занимает большее количество обращений в БД, чем обычный scan и сделать обработку данных с помощью `Lambda` функци
5. Конечный сформированный/обработанный объект `apartmentMap`, мы начианем перебирать по ключу и заносить данные в нашу коллекцию `OnlinerApartment` со `status: "NEW`

> **Ниже приведу пару monitoring графиков этой Lambda функции**

![_aws-lambda-telegram-notifier](./screenshots/.xdp_onliner-crawler-dev-onliner-crawler-monitoring.PP3SV0)

> ниже приведено логирование выполнения `Onliner-Crawler` Lambda функции c помощью сервиса `AWS CloudWatch`

```log
2020-12-20T10:19:36.758+03:00 START RequestId: bfc102c1-2368-4cdb-8fbb-fcf513aaa402 Version: $LATEST
2020-12-20T10:19:36.773+03:00 [info] Onliner Crawler
2020-12-20T10:19:36.775+03:00 [info] Formed Onliner URL: https://ak.api.onliner.by/search/apartments?page=1&limit=500
2020-12-20T10:19:38.336+03:00 [info] PAGE: 1, LIMIT: 500, URL: https://ak.api.onliner.by/search/apartments?page=1&limit=500
2020-12-20T10:19:38.337+03:00 [info] PAGE: 2, LIMIT: 500, URL: https://ak.api.onliner.by/search/apartments?page=2&limit=500
2020-12-20T10:19:38.337+03:00 [info] PAGE: 3, LIMIT: 500, URL: https://ak.api.onliner.by/search/apartments?page=3&limit=500
2020-12-20T10:19:38.337+03:00 [info] PAGE: 4, LIMIT: 500, URL: https://ak.api.onliner.by/search/apartments?page=4&limit=500
2020-12-20T10:19:38.337+03:00 [info] PAGE: 5, LIMIT: 500, URL: https://ak.api.onliner.by/search/apartments?page=5&limit=500
2020-12-20T10:19:38.337+03:00 [info] PAGE: 6, LIMIT: 500, URL: https://ak.api.onliner.by/search/apartments?page=6&limit=500
2020-12-20T10:19:38.337+03:00 [info] PAGE: 7, LIMIT: 500, URL: https://ak.api.onliner.by/search/apartments?page=7&limit=500
2020-12-20T10:19:38.337+03:00 [info] PAGE: 8, LIMIT: 500, URL: https://ak.api.onliner.by/search/apartments?page=8&limit=500
2020-12-20T10:19:38.337+03:00 [info] PAGE: 9, LIMIT: 500, URL: https://ak.api.onliner.by/search/apartments?page=9&limit=500
2020-12-20T10:19:38.338+03:00 [info] Fetch from url: https://ak.api.onliner.by/search/apartments?page=1&limit=500
2020-12-20T10:19:38.339+03:00 [info] Fetch from url: https://ak.api.onliner.by/search/apartments?page=2&limit=500
2020-12-20T10:19:38.340+03:00 [info] Fetch from url: https://ak.api.onliner.by/search/apartments?page=3&limit=500
2020-12-20T10:19:38.353+03:00 [info] Fetch from url: https://ak.api.onliner.by/search/apartments?page=4&limit=500
2020-12-20T10:19:38.354+03:00 [info] Fetch from url: https://ak.api.onliner.by/search/apartments?page=5&limit=500
2020-12-20T10:19:38.355+03:00 [info] Fetch from url: https://ak.api.onliner.by/search/apartments?page=6&limit=500
2020-12-20T10:19:38.373+03:00 [info] Fetch from url: https://ak.api.onliner.by/search/apartments?page=7&limit=500
2020-12-20T10:19:38.374+03:00 [info] Fetch from url: https://ak.api.onliner.by/search/apartments?page=8&limit=500
2020-12-20T10:19:38.375+03:00 [info] Fetch from url: https://ak.api.onliner.by/search/apartments?page=9&limit=500
2020-12-20T10:19:39.195+03:00 [info] Keys in dataMap: 0
2020-12-20T10:19:39.195+03:00 [info] Keys in batchOfData: 500
2020-12-20T10:19:39.355+03:00 [info] Keys in dataMap: 500
2020-12-20T10:19:39.356+03:00 [info] Keys in batchOfData: 500
2020-12-20T10:19:39.375+03:00 [info] Keys in dataMap: 1000
2020-12-20T10:19:39.375+03:00 [info] Keys in batchOfData: 500
2020-12-20T10:19:39.399+03:00 [info] Keys in dataMap: 1500
2020-12-20T10:19:39.399+03:00 [info] Keys in batchOfData: 500
2020-12-20T10:19:39.575+03:00 [info] Keys in dataMap: 2000
2020-12-20T10:19:39.575+03:00 [info] Keys in batchOfData: 500
2020-12-20T10:19:39.624+03:00 [info] Keys in dataMap: 2500
2020-12-20T10:19:39.633+03:00 [info] Keys in batchOfData: 500
2020-12-20T10:19:39.659+03:00 [info] Keys in dataMap: 3000
2020-12-20T10:19:39.673+03:00 [info] Keys in batchOfData: 500
2020-12-20T10:19:39.728+03:00 [info] Keys in dataMap: 3500
2020-12-20T10:19:39.733+03:00 [info] Keys in batchOfData: 426
2020-12-20T10:19:39.855+03:00 [info] Keys in dataMap: 3926
2020-12-20T10:19:39.873+03:00 [info] Keys in batchOfData: 500
2020-12-20T10:19:39.874+03:00 [info] fetching from Onliner: length: 4426
2020-12-20T10:19:39.874+03:00 [info] filterOutOnlyNewValues
2020-12-20T10:19:39.874+03:00 [info] Scan: Limit = 500
2020-12-20T10:19:40.337+03:00 [info] LastEvaluatedKey: {"id":430131}
2020-12-20T10:19:40.596+03:00 [info] LastEvaluatedKey: {"id":387010}
2020-12-20T10:19:40.975+03:00 [info] LastEvaluatedKey: {"id":623763}
2020-12-20T10:19:41.155+03:00 [info] LastEvaluatedKey: {"id":626663}
2020-12-20T10:19:41.418+03:00 [info] LastEvaluatedKey: {"id":625270}
2020-12-20T10:19:41.634+03:00 [info] LastEvaluatedKey: {"id":238964}
2020-12-20T10:19:41.774+03:00 [info] LastEvaluatedKey: {"id":624113}
2020-12-20T10:19:41.937+03:00 [info] LastEvaluatedKey: {"id":624492}
2020-12-20T10:19:42.134+03:00 [info] LastEvaluatedKey: {"id":556877}
2020-12-20T10:19:42.336+03:00 [info] LastEvaluatedKey: {"id":612366}
2020-12-20T10:19:42.456+03:00 [info] LastEvaluatedKey: {"id":585886}
2020-12-20T10:19:42.517+03:00 [info] LastEvaluatedKey: undefined
2020-12-20T10:19:42.517+03:00 [info] Total raws: 5683
2020-12-20T10:19:42.517+03:00 [info] filtered apartments from Onliner: length: 3
2020-12-20T10:19:42.517+03:00 [info] new apartment id: 627332
2020-12-20T10:19:42.534+03:00 [info] new apartment id: 627331
2020-12-20T10:19:42.534+03:00 [info] new apartment id: 627330
2020-12-20T10:19:42.593+03:00 [info] COMPLETE SUCCESS, put items: 3
2020-12-20T10:19:42.595+03:00 END RequestId: bfc102c1-2368-4cdb-8fbb-fcf513aaa402
2020-12-20T10:19:42.595+03:00 REPORT RequestId: bfc102c1-2368-4cdb-8fbb-fcf513aaa402
2020-12-20T10:19:42.595+03:00 Duration: 5836.21 ms Billed Duration: 5837 ms	Memory Size: 512 MB
2020-12-20T10:19:42.595+03:00 Max Memory Used: 140 MB Init Duration: 550.60 ms
```

## AppSync Public (GraphQL Endpoint), имя сервиса: `taphut-api-public`

> ВОТ ТУТ [public graphql schema config](../src/appsync/public/schema.graphql)

> ВОТ ТУТ [serverless.yml config file](../src/appsync/public/serverless.yml)

> ВОТ ТУТ [request.vtl](../src/appsync/public/apartments/onliner/request.vtl)

> ВОТ ТУТ [response.vtl](../src/appsync/public/apartments/onliner/response.vtl)

> **!! ВОТ ТУТ ВАЖНО БУДЕТ УПОМЯНУТЬ ПРО ТОТ САМЫЙ VTL, его реализацию**

### схема GraphQL

```graphql
schema {
  query: Query
}

type Query {
  # get onliner apartments
  onlinerApartments(limit: Int = 10, nextToken: String = null): OnlinerApartmentRowWithPagination
}

#  ...
```

### объявление GraphQL в AppSync

```yml
# ...
mappingTemplatesLocation: .
mappingTemplates:
  - dataSource: OnlinerApartment
    type: Query
    field: onlinerApartments
    request: apartments/onliner/request.vtl
    response: apartments/onliner/response.vtl
# ...
```

### request.vtl для `onlinerApartments`

```vtl
{
  "version" : "2017-02-28",
  "operation" : "Scan",
  "limit": $util.defaultIfNull($ctx.args.limit, 10),
  "nextToken": $util.toJson($util.defaultIfNull($ctx.args.nextToken, null)),
}
```

### response.vtl для `onlinerApartments`

```vtl
$util.toJson($context.result)
```

### объявление ресурса

```yml
# ...
dataSources:
  - type: AMAZON_DYNAMODB
    name: OnlinerApartment
    description: 'Onliner apartment table'
    config:
      tableName: 'OnlinerApartment'
      serviceRoleArn: '${self:custom.appSyncDynamoServiceRole}'
# ...
```

> **Ниже приведу пару monitoring графиков этого сервиса**

![appsync-public-monitoring](./screenshots/.xdp_appsync-public-monitoring.YHQCV0)

## **Разработка telegram-bot (service: telegram-bot) :**

> ВОТ ТУТ [serverless.yml config file](../src/telegram-bot/serverless.yml)

> ВОТ ТУТ [entry point (`handler` функция)](../src/telegram-bot/webhook.ts)

> **NOTE:** Важно отметить, что я выбрал реализацию Telegram-bot именно через webhook, так long polling запросы требуют открытого соединения, что не целесообразно для AWS Lambda. Так как мы плати за время выполнения функции и вообще максимально допустимое время выполнения функции состовялет не более 15 минут

> настройка функции на event от APIGateway, POST запрос на ${domain}/bot-api, CORS enabled

```yml
# ...
functions:
  webhook:
    handler: webhook.handler
    description: Taphut telegram-bot webhook
    memorySize: 256
    timeout: 30
    events:
      - http:
          path: bot-api
          method: post
          cors: true
# ...
```

Для реализации интерфейса взаимодействия пользователя с приложеним, я выбрал вариант разработки CLI интерфейса, и потом посредством его парсить входящие данные из бота, и возращать результат.

Для реализации CLI интерфейса взаимодейсвтяи был выбран паке [yargs](https://github.com/yargs/yargs).

[yargs](https://github.com/yargs/yargs) - помогает создавать интерактивные инструменты командной строки, анализируя аргументы и создавая элегантный пользовательский интерфейс.

> ВОТ ТУТ [главный файл, в котором я предостовляю builder CLI parser-a `export function buildParser`](../src/telegram-bot/cli.ts)

> ВОТ ТУТ [файл, в котором я задаю правила комманды `filter-list`](../src/telegram-bot/commands/filter-list.ts)

> ВОТ ТУТ [файл, в котором я задаю правила комманды `filter-get`](../src/telegram-bot/commands/filter-get.ts)

> ВОТ ТУТ [файл, в котором я задаю правила комманды `filter-create`](../src/telegram-bot/commands/filter-create.ts)

> ВОТ ТУТ [файл, в котором я задаю правила комманды `filter-update`](../src/telegram-bot/commands/filter-update.ts)

> ВОТ ТУТ [файл, в котором я задаю правила комманды `filter-delete`](../src/telegram-bot/commands/filter-delete.ts)

[yargs](https://github.com/yargs/yargs) пакет автоматически потом дополнит такие комманды как `help`, основываясь на моих коммандах: `filter-list`, `filter-get`, `filter-create`, `filter-update`, `filter-delete`

Так же, я переопределил метод ответа CLI парсера, вместо логгированя в консоль, конечный ответ вызовет функцию, которая отправит запрос на Telegram-API и пользователь получит ответ.

```ts
// ...

function buildResponder(token: string, chat_id: string): any {
  return function (msg: any): any {
    sendToUser({ token, chat_id, text: msg });
    console.log(msg);
  };
}

// ...
export function buildParser({ token, chatId }: buildParserParams): (stringCommand: string) => void {
  // ...

  const context: Context = {
    respond: buildResponder(token, chatId),
  };

  return (stringCommand: string) => {
    logger.info(`Command to parse: ${stringCommand}`);
    parser.parse(stringCommand || '', context, (err: any, argv: any, output: any) => {
      if (err) console.log(err.message);
      if (output) {
        argv.respond(output);
      }
    });
  };
}
// ...
```

Далее, мы обратилсь в `@BotFather` для создания телеграмм-бота, установили полученый токен в **AWS System Manager -> Parameter Store**. И сконфигурировали webhook нашего бота на endpoint APIGateway, который передаст обработку запроса уже в нашу Lambda функцию

> **Ниже приведу пару monitoring графиков этой Lambda функции**

![_aws-lambda-telegram-webhook](./screenshots/.xdp_aws-lambda-telegram-webhook.KWOUV0)

## **Разработка telegram-notifier (service: telegram-notifier) :**

> ВОТ ТУТ [serverless.yml config file](../src/telegram-notifier/serverless.yml)

> ВОТ ТУТ [entry point (`handler` функция)](../src/telegram-notifier/telegram-notifier.ts)

**Обощенный алгоритм:**

1. Scan все объявления из `DynamoDB` коллекции `OnlinerApartment` со статусом `NEW`
2. Scan все фильтры из `DynamoDB` коллекции `TelegramUserFilters`
3. для каждого объявления проверяем фильтр

   - инициализируем пустой массив `notifications`
   - инициализириуем и формируем объект `filterMapObj` типа `{ [key: chatId]: arrayOfChatFilters[] }`
   - проходим по массиву `notifications`
     - проходим по ключам объекта `filterMapObj` и достаем массивы фильтров в `chatFilters`
       - проходим по массиву фильтров `chatFilters`
       - если объявление подходит под фильтр, то заносим идентификатор чата и объявление в массив `notifications` и переходим к следующему ключу объектав `filterMapObj`

4. Запускаем параллельную обработку запросов массива `notifications`, отсылаем пользователю объявление с помощью `sendToUser(filter.chatID, convertApartmentToMsg(apartment))`
5. Изменяем статус всех объявлений с `NEW` на `OLD`

> ниже приведена часть кода из [serverless.yml config file](../src/telegram-notifier/serverless.yml), в котором настраивается `schedule` событие, которое будет запускать данную функцию каждые 15 минут

```yml
functions:
  telegram-notifier:
    handler: telegram-notifier.handler
    description: Taphut telegram-bot webhook
    memorySize: 256
    timeout: 300
    events:
      - schedule:
          name: telegram-notifier-event
          description: 'Scan all users filters and search for suitable new appartment'
          rate: rate(15 minutes)
```

> ниже приведено логирование выполнения `telegram-notifier` Lambda функции c помощью сервиса `AWS CloudWatch`

```log
2020-12-21T12:25:08.573+03:00	START RequestId: 555982da-0494-4620-a227-bc1bb124f74c Version: $LATEST
2020-12-21T12:25:08.611+03:00	[info] Telegram-notifier start
2020-12-21T12:25:08.633+03:00	[info] filterOutOnlyNewValues
2020-12-21T12:25:08.671+03:00	[info] Scan: Limit = undefined
2020-12-21T12:25:09.030+03:00	[info] LastEvaluatedKey: {"id":627016}
2020-12-21T12:25:09.085+03:00	[info] LastEvaluatedKey: {"id":577312}
2020-12-21T12:25:09.146+03:00	[info] LastEvaluatedKey: {"id":626387}
2020-12-21T12:25:09.170+03:00	[info] LastEvaluatedKey: undefined
2020-12-21T12:25:09.171+03:00	[info] Total raws: 1
2020-12-21T12:25:09.171+03:00	[info] newApartments count: 1
2020-12-21T12:25:09.194+03:00	[info] filters count: 12
2020-12-21T12:25:09.212+03:00	[info] Total notifications count: 0
2020-12-21T12:25:09.231+03:00	[info] keys for updated to OLD: [{"id":627342}]
2020-12-21T12:25:09.252+03:00	[info] Apartments status is updated to OLD
2020-12-21T12:25:09.252+03:00	[info] Telegram-notifier complete
2020-12-21T12:25:09.271+03:00	END RequestId: 555982da-0494-4620-a227-bc1bb124f74c
2020-12-21T12:25:09.271+03:00	REPORT RequestId: 555982da-0494-4620-a227-bc1bb124f74c
2020-12-21T12:25:09.271+03:00 Duration: 698.46 ms	Billed Duration: 699 ms	Memory Size: 256 MB
2020-12-21T12:25:09.271+03:00 Max Memory Used: 95 MB Init Duration: 569.51 ms
```

> **Ниже приведу пару monitoring графиков этой Lambda функции**

![_aws-lambda-telegram-notifier](./screenshots/.xdp_aws-lambda-telegram-notifirer-monitoring.OTROV0)

## **3.5 описание разработки Angular client-а + настройка его CI/DI?**

Для frontend-a создан отдельный репозиторий на [Github](https://github.com/Fomin2402/taphut-front).

Первым делом, была продумана архитектура DOM-a Angular приложения:

```sh
root
├── auth/signin
├── auth/signup
├── auth/signup/confirm
├── auth/password/forger
├── auth/password/forger/confirm
├── auth/password/change (canActivate: AuthenticationGuard)
└── main (canActivate: AuthenticationGuard)
   ├── Telegram OAuth
   └── property rental ads


```

Первым делом, надо было реализовать Аутентификацию/Авторизацию. Для этого нам понадобиться [Amplify библиоетка](https://docs.amplify.aws/), для обращения к нашем AWS Cognito сервису. Тут мы столкнулись с неудобством использования этой библиотеки, тк в Angular-е очень удобно использовать реактивный подход с помощью `Rxjs`. Поэтому была написан первый варант обертки над Amplify для удобного взаимодействия. ([ссылка тут](https://github.com/Fomin2402/taphut-front/blob/master/src/app/services/amplify.service.ts)).

После этого, следующим шагом была реализация `AuthenticationGuard`, для защиты перехода не аутентифицированного юезра на страницы приложения ([ссылка на AuthenticationGuard](https://github.com/Fomin2402/taphut-front/blob/master/src/app/guards/authentication.guard.ts)). Его мы будем использовать в определении `Rouets` [тут](https://github.com/Fomin2402/taphut-front/blob/master/src/app/app-routing.module.ts). Сделан таким образом, что если неаутентифицированный пользователь захочет перейти на закрытую страницу, то он будем перенаправлен на страницу `login-a`.

Следующим шагом было подключение UI библиотеки [Angular Material](https://material.angular.io/). Его преимущества:

- Интернационализированные и доступные компоненты для всех. Хорошо протестирован, чтобы гарантировать производительность и надежность.
- Простые API с последовательным кроссплатформенным поведением.
- Универсальный. Предоставьте инструменты, которые помогут разработчикам создавать собственные настраиваемые компоненты с общими шаблонами взаимодействия.
- Настраивается в рамках спецификации Material Design.
- Создан командой Angular для интеграции с Angular имея высокую производительность/эффективность.

После того, как мы подключили [Angular Material](https://material.angular.io/), первым делом в `root` компоненте реализовал `header`:

```html
<mat-toolbar color="primary" class="example-toolbar">
  <h1 class="header-title big">Taphut</h1>
  <span class="flex-1"></span>

  <button *ngIf="amplify.isAuthenticatedSubj | async" mat-button (click)="logout()">logout</button>
  <a
    *ngIf="amplify.isAuthenticatedSubj | async"
    mat-button
    [routerLink]="['/', 'auth', 'password', 'change']"
    >password change</a
  >
  <a
    *ngIf="!(amplify.isAuthenticatedSubj | async)"
    mat-button
    [routerLink]="['/', 'auth', 'signin']"
    >signin</a
  >
  <a
    *ngIf="!(amplify.isAuthenticatedSubj | async)"
    mat-button
    [routerLink]="['/', 'auth', 'signup']"
    >signup</a
  >
</mat-toolbar>

<router-outlet></router-outlet>
```

Далее надо было реазиловать `GraphQL` севрис, который позволит нам взаимодействовать с нашем бэком посредством `GraphQL API`. Первым делом, решил реализовать на главной странице показ объявления по аренде недвижимости с `infinite-scroll` пагинецией.

> [код на GraphQL сервис](https://github.com/Fomin2402/taphut-front/blob/master/src/app/graphql.module.ts)

> [код на сервис, который будет предоставлять API для получения объявлений](https://github.com/Fomin2402/taphut-front/blob/master/src/app/services/product.service.ts)

> [код на компонент, который будет обращауется к сервису за объявлениями, а потом их выводит](https://github.com/Fomin2402/taphut-front/blob/master/src/app/components/shell/shell.component.ts)

Следующим шагом стало добавления [Telegram Login Widget](https://core.telegram.org/widgets/login), чтобы в будущем позволить web-клиенту привязать к своей учетной записи чат с ботом из телеграмма. Это нужно, чтобы в будущем добавить функционал, для более удобного редактирования фильтров, просмотра объявлений и статистики с помощью браузерного клиента, при этом получая нотификации в `Telegram` клиенте.

Первая сложность в реализации [Telegram Login Widget](https://core.telegram.org/widgets/login) стало то, что в Angular нельзя просто так вставить в разметку тег `<script>`.
Я создал компонент, который эо обходит, добавляя динамически в разметку необходимый `<script>`. [Ссылка на `telegram component`](https://github.com/Fomin2402/taphut-front/blob/master/src/app/components/telegram/telegram.component.ts).

> тут важно упомянуть, что динамическая вставка в DOM должна происходить именно в `AfterViewInit` **lifecycle hook-e**.

Далее, для корректной работы [Telegram Login Widget](https://core.telegram.org/widgets/login) необходимо запустить приложение на `https`. На этом этапе я решил подключить CI/DI для более удобной работы/тестирования моего Angular приложения.

В качестве CI/DI инструмента я выбрал облачного провайдера [Vercel](https://vercel.com).

[Vercel](https://vercel.com) - это облачная платформа для статических сайтов и бессерверных функций, которая идеально подходит для вашего рабочего процесса. Он позволяет разработчикам размещать веб-сайты и веб-службы Jamstack, которые мгновенно развертываются, автоматически масштабируются и не требуют контроля, и все это без настройки.

> **Jamstack** - это новая стандартная архитектура для Интернета. Используя рабочие процессы Git и современные инструменты сборки, предварительно обработанный контент передается в CDN и становится динамическим с помощью API и бессерверных функций. Технологии в стеке включают фреймворки JavaScript, генераторы статических сайтов, безголовые CMS и CDN.

> **Ниже приведу пример ng version**

![ng-version](./screenshots/.xdp_ng-version.GRN5V0)

> **Ниже приведу пример Vercel dashboard**

![vercel-dashboard](./screenshots/vercel-dashboard.png)

> **Ниже приведу пример деплоя master ветки**

![vercel-master](./screenshots/vercel-master.png)

> **Ниже приведу пример деплоя ветки, когда произошла ошибка сборки**

![vercel-error](./screenshots/vercel-error.png)

> **Ниже приведу пример настройки domain-a**

![vercel-domain-settings](./screenshots/.xdp_vercel-domain-settings.8KJ1V0)

Ниже приведена структура angular проекта:

```sh
~/taphut-front
├── README.md
├── angular.json
├── e2e
|  ├── protractor.conf.js
|  ├── src
|  |  ├── app.e2e-spec.ts
|  |  └── app.po.ts
|  └── tsconfig.json
├── karma.conf.js
├── package-lock.json
├── package.json
├── src
|  ├── app
|  |  ├── app-routing.module.ts
|  |  ├── app.component.html
|  |  ├── app.component.scss
|  |  ├── app.component.spec.ts
|  |  ├── app.component.ts
|  |  ├── app.module.ts
|  |  ├── components
|  |  |  ├── change-password
|  |  |  ├── confirm-signup
|  |  |  ├── forgot-password
|  |  |  ├── forgot-password-submit
|  |  |  ├── shell
|  |  |  ├── signin
|  |  |  ├── signup
|  |  |  └── telegram
|  |  ├── graphql.module.ts
|  |  ├── guards
|  |  |  └── authentication.guard.ts
|  |  ├── services
|  |  |  ├── amplify.service.spec.ts
|  |  |  ├── amplify.service.ts
|  |  |  ├── product.service.spec.ts
|  |  |  └── product.service.ts
|  |  └── utils
|  |     ├── form-validators.ts
|  |     ├── models.ts
|  |     └── routes.ts
|  ├── assets
|  ├── environments
|  |  ├── environment.prod.ts
|  |  └── environment.ts
|  ├── favicon.ico
|  ├── index.html
|  ├── main.ts
|  ├── polyfills.ts
|  ├── styles.scss
|  └── test.ts
├── tsconfig.app.json
├── tsconfig.json
├── tsconfig.spec.json
└── tslint.json
```

# **Тестирование**

## Для фронта использован Karma + Jasmine ??? ([ссылка](https://angular.io/guide/testing))

> [тут](https://github.com/Fomin2402/taphut-front/blob/feature/store/src/app/pages/apartments/store/actions/apartments.actions.spec.ts) код тестов для angular (тесты Action-ов)

> [тут](https://github.com/Fomin2402/taphut-front/blob/feature/store/src/app/pages/apartments/store/reducers/apartments.reducer.spec.ts) код тестов для angular (тесты Reducer-a)

> [тут](https://github.com/Fomin2402/taphut-front/blob/feature/store/src/app/pages/apartments/store/selectors/apartments.selectors.spec.ts) код тестов для angular (тесты Selector-ов)

> **Тесты Angular**

![angular-tests](./screenshots/angular-tests.png)

> **Тесты Angular 2**

![angular-tests](./screenshots/angular-tests-2.png)

> **Тесты Backend**

## Для бэка использован фреймворк jest

> [тут](../src/utils/async.test.ts) код тестов для back-a (тесты async обертки)

> [тут](../src/utils/date.test.ts) код тестов для back-a (тесты date конвертеров)

> [тут](../src/utils/dynamodb.test.ts) код тестов для back-a (тест очистки объекта)

![angular-tests](./screenshots/back-tests.png)

## описание тестирования

# **Руководство программиста**

1. необходимо ознакомиться с AWS, AWS-Vault, Serverless, Terraform, Vercel, Anuglar, Telegram API
2. Создать аккаунт на AWS, задать креды локально в AWS-Vault
3. создать `terraform backend`

```sh
cd ./terraform/init-stored-state/on-dev
aws-vault exec ${your_account} -- terraform init
aws-vault exec ${your_account} -- terraform apply
```

4. развернуть ресурсы, которые управляются с помощью `terraform`

```sh
cd ./terraform/dev
aws-vault exec ${your_account} -- terraform init
aws-vault exec ${your_account} -- terraform plan
aws-vault exec ${your_account} -- terraform apply
```

5. создать вручную `Telegram-bot` и добавить его токен в `AWS KMS`
6. начать разворачивать `Serverless` ресурсы в определенном порядке

```sh
yarn sls ${your_account} src/telegram-bot deploy -v
yarn sls ${your_account} src/telegram-notifier deploy -v
yarn sls ${your_account} src/onliner-crawler deploy -v
yarn sls ${your_account} src/appsync/public deploy -v
```

7. установить `webhook` для бота, установив в `set-telegram-webhook.ts` `newEndpoint` и после вызвав скрипт

```sh
yarn script-dev src/script/set-telegram-webhook.ts
```

8. Вручную на Vercel натсроить CI/DI `taphut-front` репозитория

## описание руководства программиста

# Ссылки

1. [Onliner.by](Onliner.by)
2. [Realt.by](https://realt.by/)
3. [Domovita.by](https://domovita.by/)
4. [TypeScript](https://www.typescriptlang.org/docs/handbook/utility-types.html)
5. [ESLint](https://eslint.org/docs/user-guide/configuring)
6. [TSLint](https://palantir.github.io/tslint/)
7. [Prettier](https://prettier.io/docs/en/options.html)
8. [Webpack](https://webpack.js.org/)
9. [Yarn](https://classic.yarnpkg.com/en/docs/)
10. [Serverless](https://www.serverless.com/)
11. [Terraform](https://www.terraform.io/)
12. [Vercel](https://vercel.com/docs)
13. [AWS-Vault](https://github.com/99designs/aws-vault)
14. [Github](https://github.com/)
15. [AWS Cognito](https://docs.aws.amazon.com/cognito/)
16. [AWS S3](https://docs.aws.amazon.com/s3/index.html)
17. [AWS DynamoDB](https://docs.aws.amazon.com/dynamodb/index.html)
18. [AWS Lambda](https://docs.aws.amazon.com/lambda/index.html)
19. [AWS AppSync](https://docs.aws.amazon.com/appsync/latest/devguide/welcome.html)
20. [AWS VTL](https://docs.aws.amazon.com/appsync/latest/devguide/resolver-context-reference.html)
21. [AWS APIGateway](https://docs.aws.amazon.com/apigateway/index.html)
22. [AWS CloudFormation](https://docs.aws.amazon.com/cloudformation/)
23. [AWS System Manager](https://docs.aws.amazon.com/systems-manager/index.html)
24. [AWS KMS](https://aws.amazon.com/kms/)
25. [AWS CloudWatch](https://docs.aws.amazon.com/cloudwatch/index.html)
26. [AWS Amplify](https://docs.amplify.aws/)
27. [AWS SNS](https://docs.aws.amazon.com/sns/index.html)
28. [Angular](https://angular.io/)
29. [Telegam API](https://core.telegram.org/)
30. [AWS Vault](https://github.com/99designs/aws-vault)

## Ссылки

1. [Onliner.by](Onliner.by)
2. [Realt.by](https://realt.by/)
3. [Domovita.by](https://domovita.by/)
4. [TypeScript](https://www.typescriptlang.org/docs/handbook/utility-types.html)
5. [ESLint](https://eslint.org/docs/user-guide/configuring)
6. [TSLint](https://palantir.github.io/tslint/)
7. [Prettier](https://prettier.io/docs/en/options.html)
8. [Webpack](https://webpack.js.org/)
9. [Yarn](https://classic.yarnpkg.com/en/docs/)
10. [Serverless](https://www.serverless.com/)
11. [Terraform](https://www.terraform.io/)
12. [Vercel](https://vercel.com/docs)
13. [AWS-Vault](https://github.com/99designs/aws-vault)
14. [Github](https://github.com/)
15. [AWS Cognito](https://docs.aws.amazon.com/cognito/)
16. [AWS S3](https://docs.aws.amazon.com/s3/index.html)
17. [AWS DynamoDB](https://docs.aws.amazon.com/dynamodb/index.html)
18. [AWS Lambda](https://docs.aws.amazon.com/lambda/index.html)
19. [AWS AppSync](https://docs.aws.amazon.com/appsync/latest/devguide/welcome.html)
20. [AWS VTL](https://docs.aws.amazon.com/appsync/latest/devguide/resolver-context-reference.html)
21. [AWS APIGateway](https://docs.aws.amazon.com/apigateway/index.html)
22. [AWS CloudFormation](https://docs.aws.amazon.com/cloudformation/)
23. [AWS System Manager](https://docs.aws.amazon.com/systems-manager/index.html)
24. [AWS KMS](https://aws.amazon.com/kms/)
25. [AWS CloudWatch](https://docs.aws.amazon.com/cloudwatch/index.html)
26. [AWS Amplify](https://docs.amplify.aws/)
27. [AWS SNS](https://docs.aws.amazon.com/sns/index.html)
28. [Angular](https://angular.io/)
29. [Telegam API](https://core.telegram.org/)
30. [AWS Vault](https://github.com/99designs/aws-vault)
